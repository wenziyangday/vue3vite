1.ref reactive 的区别
  reactive() 的局限性：
    仅对对象类型（复合类型）数据有效，对基本类型数据无效
    由于vue的响应式系统是通过属性访问追踪的，因此我们必须始终保持对该响应式对象的相同引用。这意味着我们不可以随意的替换一个响应式对象，
      这样操作将使初始引用失效（覆盖原有引用），从而失去响应性

  ref() 允许我们创建任意类型的数据引用，并能够在不失响应性的前提下传递这些引用。
    基本类型数据 ref 会进行自动解包，而复合数据类型不会进行数据解包

2.dom的更新并不是同步的，
  Vue 将缓冲它们直到更新周期的 “下个时机” 以确保无论你进行了多少次状态更改，每个组件都只更新一次。

3.计算属性
  模板中使用方法和使用计算属性都能获得相同的效果
  区别是：
    使用计算属性会基于其响应式依赖被缓存，
    而使用方法则是在其重新渲染时，即使不变也会重新渲染

  可写计算属性：
    计算属性中存在 自己的 getter 和 setter 方法用于接收和修改
    但是注意的是：
      避免执行修改计算属性
      getter 中不应存在异步 函数 或者dom更新（副作用）

4.v-for
  Vue 默认按照“就地更新”的策略来更新通过 v-for 渲染的元素列表。当数据项的顺序改变时，
  Vue 不会随之移动 DOM 元素的顺序，而是就地更新每个元素，确保它们在原本指定的索引位置上渲染。

5.注册周期钩子函数
  当调用 onMounted 时，Vue 会自动将回调函数注册到当前正被初始化的组件实例上。
  这意味着这些钩子应当在组件初始化时被同步注册（同一个执行上下文）

6.侦听器
  场景：
    计算属性允许我们声明性地计算衍生值。
    然而在有些情况下，我们需要在状态变化时执行一些“副作用”：例如更改 DOM，或是根据异步操作的结果去修改另一处的状态。
  侦听的数据源类型：
    watch 的第一个参数可以是不同形式的“数据源”：
      它可以是一个 ref (包括计算属性)、一个响应式对象、
      一个 getter 函数、或多个数据源组成的数组：

      注意，你不能直接侦听响应式对象的属性值，需要将响应式数据转换成一个getter函数
      需要注意的是：直接侦听响应式对象，会隐式的创建一个  深层侦听器（该回调函数在所有的嵌套变更时都会触发）
      相比之下，一个返回响应式对象的getter函数，只有在返回不同的对象时，才会触发回调（当然也可以在此基础上手动添加deep选项，从而强制转换为深层监听）

      在侦听器中使用选项immediate 时带来的效果是：同步执行一次（加载过程中立即执行）（强制侦听器的回调立即执行）

      watch vs. watchEffect
        watch 和 watchEffect 都能响应式地执行有副作用的回调。它们之间的主要区别是追踪响应式依赖的方式：
        watch 只追踪明确侦听的数据源。它不会追踪任何在回调中访问到的东西。另外，仅在数据源确实改变时才会触发回调。watch 会避免在发生副作用时追踪依赖，因此，我们能更加精确地控制回调函数的触发时机。
        watchEffect，则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式属性。这更方便，而且代码往往更简洁，但有时其响应性依赖关系会不那么明确。


      回调的触发时机#
        当你更改了响应式状态，它可能会同时触发 Vue 组件更新和侦听器回调。
        默认情况下，用户创建的侦听器回调，都会在 Vue 组件更新之前被调用。这意味着你在侦听器回调中访问的 DOM 将是被 Vue 更新之前的状态。
        如果想在侦听器回调中能访问被 Vue 更新之后的 DOM，你需要指明 flush: 'post' 选项：


      停用侦听器：
        在 setup() 或 <script setup> 中用同步语句创建的侦听器，会自动绑定到宿主组件实例上，并且会在宿主组件卸载时自动停止。因此，在大多数情况下，你无需关心怎么停止一个侦听器。
        一个关键点是，侦听器必须用同步语句创建：如果用异步回调创建一个侦听器，那么它不会绑定到当前组件上，你必须手动停止它，以防内存泄漏。

        注意，需要异步创建侦听器的情况很少，请尽可能选择同步创建。如果需要等待一些异步数据，你可以使用条件式的侦听逻辑：


7.模板引用
  使用了 <script setup> 的组件是默认私有的：一个父组件无法访问到一个使用了 <script setup> 的子组件中的任何东西，除非子组件在其中通过 defineExpose 宏显式暴露：

8.组件
  组件中的数据，事件的传递
    defineProps, defineEmits
